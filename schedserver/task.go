package schedserver

import (
	"context"
	"errors"
	"fmt"
	api "github.com/arthurfabre/scheduler/schedapi"
	"github.com/arthurfabre/scheduler/schedserver/pb"
	"github.com/coreos/etcd/clientv3"
	"github.com/coreos/etcd/clientv3/clientv3util"
	"github.com/golang/protobuf/proto"
	"github.com/satori/go.uuid"
	"log"
	"time"
)

const (
	// See README/#ETCD Key Schema
	taskPrefix = "task/"
	taskFmt    = taskPrefix + "%s"

	statusPrefix = taskPrefix + "status/"
	queuedFmt    = statusPrefix + "queued/%s"
	runningFmt   = statusPrefix + "running/%s/%s"
	completeFmt  = statusPrefix + "complete/%d/%s"
	canceledFmt  = statusPrefix + "canceled/%d/%s"
)

// Task handles storing and updating tasks (and their status) in etcd.
// Tasks embeds the pb.Task implementation generated by protoc.
type Task struct {
	*pb.Task

	// Version in etcd when this was last updated / retrieved
	version int64

	// Key in etcd
	key string
}

// newTask constructs a Task from a TaskRequest, assigining it a UUID.
// Nothing is submitted to etcd.
func newTask(req *api.TaskRequest) *Task {
	id := &api.TaskID{uuid.NewV4().String()}

	return &Task{key: taskKey(id), Task: &pb.Task{Request: req, Id: id}}
}

// getTask retrieves a Task from etcd.
func getTask(client *clientv3.Client, ctx context.Context, id *api.TaskID) (*Task, error) {
	key := taskKey(id)

	resp, err := client.Get(ctx, key)
	if err != nil {
		return nil, err
	}

	// We're not searching for a range or prefix
	if resp.Count != 1 {
		log.Fatalln("Too many matching keys, found:", resp.Count)
	}

	task := &Task{version: resp.Kvs[0].Version, key: key, Task: &pb.Task{}}
	if err := proto.Unmarshal([]byte(resp.Kvs[0].Value), task.Task); err != nil {
		return nil, err
	}

	// Ensure what we requested and what we got back match up
	if task.Id.Uuid != id.Uuid {
		return nil, fmt.Errorf("Requested task %s, received %s", id.Uuid, task.Id.Uuid)
	}

	return task, nil
}

// taskKey returns the etcd key for a TaskID
func taskKey(id *api.TaskID) string {
	return fmt.Sprintf(taskFmt, id.Uuid)
}

// statusKey returns the etcd status key of a Task for a given TaskStatus
func (t *Task) statusKey(status *api.TaskStatus) string {
	switch status.Status.(type) {
	case *api.TaskStatus_Queued_:
		return fmt.Sprintf(queuedFmt, t.Id.Uuid)
	case *api.TaskStatus_Running_:
		return fmt.Sprintf(runningFmt, status.GetRunning().NodeId.Uuid, t.Id.Uuid)
	case *api.TaskStatus_Complete_:
		return fmt.Sprintf(completeFmt, status.GetComplete().Epoch, t.Id.Uuid)
	case *api.TaskStatus_Canceled_:
		return fmt.Sprintf(canceledFmt, status.GetCanceled().Epoch, t.Id.Uuid)
	default:
		// TODO - Is this wise?
		panic("Unexpected Task status")
	}
}

// setStatus Updates the status of a Task, and updates the Task and its status key in etcd
func (t *Task) setStatus(client *clientv3.Client, ctx context.Context, newStatus *api.TaskStatus) (err error) {
	// Preserve old status to know which old key to delete
	oldStatus := t.Status
	t.Status = newStatus

	// If there's an error, ensure we set the oldStatus back
	defer func() {
		if err != nil {
			t.Status = oldStatus
		}
	}()

	data, err := proto.Marshal(t.Task)
	if err != nil {
		return
	}

	kvc := clientv3.NewKV(client)

	// We always need to update the task and its status key
	thens := []clientv3.Op{
		clientv3.OpPut(t.key, string(data)),
		clientv3.OpPut(t.statusKey(newStatus), ""),
	}

	// If a previous status was set, cleanup its key
	if oldStatus != nil {
		thens = append(thens, clientv3.OpDelete(t.statusKey(oldStatus)))
	}

	var ifCheck clientv3.Cmp
	if t.version > 0 {
		// If the Task was already stored, ensure it hasn't changed
		ifCheck = clientv3.Compare(clientv3.Version(t.key), "=", t.version)
	} else {
		// If it was never stored, ensure no one else has stolen that key
		ifCheck = clientv3util.KeyMissing(t.key)
	}

	resp, err := kvc.Txn(ctx).If(ifCheck).Then(thens...).Commit()

	if err != nil {
		return
	}

	if !resp.Succeeded {
		err = errors.New("Unexpected concurrent Task modification")
		return
	}

	// Feels hacky, but PutResponse doesn't include the new version
	t.version++

	return nil
}

// queue marks the Task as "queued" in etcd.
func (t *Task) queue(client *clientv3.Client, ctx context.Context) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Queued_{&api.TaskStatus_Queued{}}})
}

// run marks the Task as "running" on nodeID in etcd.
func (t *Task) run(client *clientv3.Client, ctx context.Context, nodeID *api.NodeID) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Running_{&api.TaskStatus_Running{nodeID}}})
}

// complete marks the Task as "complete" on nodeID, with exitCode, as of now, in etcd.
func (t *Task) complete(client *clientv3.Client, ctx context.Context, nodeID *api.NodeID, exitCode int) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Complete_{&api.TaskStatus_Complete{nodeID, int32(exitCode), time.Now().Unix()}}})
}

// cancel marks the Task as "canceled" as of now, in etcd.
func (t *Task) cancel(client *clientv3.Client, ctx context.Context) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Canceled_{&api.TaskStatus_Canceled{time.Now().Unix()}}})
}
