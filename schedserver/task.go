package schedserver

import (
	"context"
	"errors"
	"fmt"
	api "github.com/arthurfabre/scheduler/schedapi"
	"github.com/arthurfabre/scheduler/schedserver/pb"
	"github.com/coreos/etcd/clientv3"
	"github.com/coreos/etcd/clientv3/clientv3util"
	"github.com/golang/protobuf/proto"
	"github.com/satori/go.uuid"
	"log"
	"strings"
	"time"
)

// Format strings for keys. Don't include the last %s for the Task UUID
// See README/#ETCD Key Schema
const (
	taskFmt     = "task/"
	statusFmt   = taskFmt + "status/"
	queuedFmt   = statusFmt + "queued/"
	runningFmt  = statusFmt + "running/%s/"
	completeFmt = statusFmt + "complete/%d/"
	canceledFmt = statusFmt + "canceled/%d/"
)

// Task handles storing and updating tasks (and their status) in etcd.
// Tasks embeds the pb.Task implementation generated by protoc.
type Task struct {
	*pb.Task

	// Version in etcd when this was last updated / retrieved
	version int64

	// Key in etcd
	key string
}

// watchQueuedTasks returns a Channel of Tasks that have just been queued
// TODO - Potentially expose DELETE events, so we can backoff before stealing tasks
func watchQueuedTasks(client *clientv3.Client, ctx context.Context) <-chan *Task {
	out := make(chan *Task)

	// TODO - Are we cleaning things up properly?
	go func() {
		for resp := range client.Watch(ctx, queuedFmt, clientv3.WithPrefix(), clientv3.WithFilterDelete()) {
			for _, ev := range resp.Events {
				task, err := getTask(client, ctx, keyID(string(ev.Kv.Key)))
				if err != nil {
					continue
				}

				out <- task
			}
		}
	}()

	return out
}

// listDoneTasks returns a list of Tasks that were done (completed or canceled) at least age seconds ago.
func listDoneTasks(client *clientv3.Client, ctx context.Context, age int64) ([]*Task, error) {
	list := func(preFmt string) ([]*Task, error) {
		// Get everything from epoch 0 to (Now - age)
		return listTasks(client, ctx, fmt.Sprintf(preFmt, 0), clientv3.WithRange(fmt.Sprintf(preFmt, time.Now().Unix())))
	}

	co, err := list(completeFmt)
	if err != nil {
		return nil, err
	}

	ca, err := list(canceledFmt)
	if err != nil {
		return nil, err
	}

	return append(co, ca...), nil
}

// listNodeTasks returns a list of Tasks that are being run by nodeId.
func listNodeTasks(client *clientv3.Client, ctx context.Context, nodeId *api.NodeID) ([]*Task, error) {
	return listTasks(client, ctx, fmt.Sprintf(runningFmt, nodeId.Uuid), clientv3.WithPrefix())
}

// listTasks returns a list of Tasks using etcd GET(key, opts...). Intended to be used with status keys.
func listTasks(client *clientv3.Client, ctx context.Context, key string, opts ...clientv3.OpOption) ([]*Task, error) {
	resp, err := client.Get(ctx, key, opts...)
	if err != nil {
		return nil, err
	}

	tasks := make([]*Task, 0, resp.Count)

	for _, t := range resp.Kvs {
		task, err := getTask(client, ctx, keyID(string(t.Key)))
		if err != nil {
			continue
		}

		tasks = append(tasks, task)
	}

	return tasks, nil
}

// newTask constructs a Task from a TaskRequest, assigining it a UUID.
// Nothing is submitted to etcd.
func newTask(req *api.TaskRequest) *Task {
	id := &api.TaskID{uuid.NewV4().String()}

	return &Task{key: taskKey(id), Task: &pb.Task{Request: req, Id: id}}
}

// getTask retrieves a Task from etcd.
func getTask(client *clientv3.Client, ctx context.Context, id *api.TaskID) (*Task, error) {
	key := taskKey(id)

	resp, err := client.Get(ctx, key)
	if err != nil {
		return nil, err
	}

	// We're not searching for a range or prefix
	if resp.Count != 1 {
		log.Fatalln("Too many matching keys, found:", resp.Count)
	}

	task := &Task{version: resp.Kvs[0].Version, key: key, Task: &pb.Task{}}
	if err := proto.Unmarshal([]byte(resp.Kvs[0].Value), task.Task); err != nil {
		return nil, err
	}

	// Ensure what we requested and what we got back match up
	if task.Id.Uuid != id.Uuid {
		return nil, fmt.Errorf("Requested task %s, received %s", id.Uuid, task.Id.Uuid)
	}

	return task, nil
}

// taskKey returns the etcd key for a TaskID
func taskKey(id *api.TaskID) string {
	return idKey(taskFmt, id)
}

// statusKey returns the etcd status key of a Task for a given TaskStatus
func (t *Task) statusKey(status *api.TaskStatus) string {
	// Ensures the Task ID is passed in
	key := func(format string, args ...interface{}) string {
		return idKey(format, t.Id, args...)
	}

	switch status.Status.(type) {
	case *api.TaskStatus_Queued_:
		return key(queuedFmt)
	case *api.TaskStatus_Running_:
		return key(runningFmt, status.GetRunning().NodeId.Uuid)
	case *api.TaskStatus_Complete_:
		return key(completeFmt, status.GetComplete().Epoch)
	case *api.TaskStatus_Canceled_:
		return key(canceledFmt, status.GetCanceled().Epoch)
	default:
		// TODO - Is this wise?
		panic("Unexpected Task status")
	}
}

// keyID converts a status / task key, to a TaskID
func keyID(key string) *api.TaskID {
	s := strings.Split(key, "/")
	return &api.TaskID{Uuid: s[len(s)-1]}
}

// idKey converts a TaskID to a status / task key
func idKey(format string, key *api.TaskID, args ...interface{}) string {
	return fmt.Sprintf(format+"%s", append(args, key.Uuid)...)
}

// setStatus Updates the status of a Task, and updates the Task and its status key in etcd
func (t *Task) setStatus(client *clientv3.Client, ctx context.Context, newStatus *api.TaskStatus) (err error) {
	// Preserve old status to know which old key to delete
	oldStatus := t.Status
	t.Status = newStatus

	// If there's an error, ensure we set the oldStatus back
	defer func() {
		if err != nil {
			t.Status = oldStatus
		}
	}()

	data, err := proto.Marshal(t.Task)
	if err != nil {
		return
	}

	kvc := clientv3.NewKV(client)

	// We always need to update the task and its status key
	thens := []clientv3.Op{
		clientv3.OpPut(t.key, string(data)),
		clientv3.OpPut(t.statusKey(newStatus), ""),
	}

	// If a previous status was set, cleanup its key
	if oldStatus != nil {
		thens = append(thens, clientv3.OpDelete(t.statusKey(oldStatus)))
	}

	var ifCheck clientv3.Cmp
	if t.version > 0 {
		// If the Task was already stored, ensure it hasn't changed
		ifCheck = clientv3.Compare(clientv3.Version(t.key), "=", t.version)
	} else {
		// If it was never stored, ensure no one else has stolen that key
		ifCheck = clientv3util.KeyMissing(t.key)
	}

	resp, err := kvc.Txn(ctx).If(ifCheck).Then(thens...).Commit()

	if err != nil {
		return
	}

	if !resp.Succeeded {
		err = errors.New("Unexpected concurrent Task modification")
		return
	}

	// Feels hacky, but PutResponse doesn't include the new version
	t.version++

	return nil
}

// queue marks the Task as "queued" in etcd.
func (t *Task) queue(client *clientv3.Client, ctx context.Context) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Queued_{&api.TaskStatus_Queued{}}})
}

// run marks the Task as "running" on nodeID in etcd.
func (t *Task) run(client *clientv3.Client, ctx context.Context, nodeID *api.NodeID) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Running_{&api.TaskStatus_Running{nodeID}}})
}

// complete marks the Task as "complete" on nodeID, with exitCode, as of now, in etcd.
func (t *Task) complete(client *clientv3.Client, ctx context.Context, nodeID *api.NodeID, exitCode int) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Complete_{&api.TaskStatus_Complete{nodeID, int32(exitCode), time.Now().Unix()}}})
}

// cancel marks the Task as "canceled" as of now, in etcd.
func (t *Task) cancel(client *clientv3.Client, ctx context.Context) error {
	return t.setStatus(client, ctx, &api.TaskStatus{&api.TaskStatus_Canceled_{&api.TaskStatus_Canceled{time.Now().Unix()}}})
}
